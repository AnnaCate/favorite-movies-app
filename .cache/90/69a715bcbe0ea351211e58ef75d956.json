{"id":"../node_modules/highlight-words-core/dist/index.js","dependencies":[{"name":"/Users/annafulton/Documents/JRS/my-projects/favorite-movies-app/node_modules/highlight-words-core/dist/index.js.map","includedInParent":true,"mtime":1519058163000},{"name":"/Users/annafulton/Documents/JRS/my-projects/favorite-movies-app/package.json","includedInParent":true,"mtime":1562958302000},{"name":"/Users/annafulton/Documents/JRS/my-projects/favorite-movies-app/node_modules/highlight-words-core/package.json","includedInParent":true,"mtime":1562958301000}],"generated":{"js":"module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tObject.defineProperty(exports, 'combineChunks', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _utils.combineChunks;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'fillInChunks', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _utils.fillInChunks;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'findAll', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _utils.findAll;\n\t  }\n\t});\n\tObject.defineProperty(exports, 'findChunks', {\n\t  enumerable: true,\n\t  get: function get() {\n\t    return _utils.findChunks;\n\t  }\n\t});\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.\n\t * @return Array of \"chunks\" (where a Chunk is { start:number, end:number, highlight:boolean })\n\t */\n\tvar findAll = exports.findAll = function findAll(_ref) {\n\t  var autoEscape = _ref.autoEscape,\n\t      _ref$caseSensitive = _ref.caseSensitive,\n\t      caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,\n\t      _ref$findChunks = _ref.findChunks,\n\t      findChunks = _ref$findChunks === undefined ? defaultFindChunks : _ref$findChunks,\n\t      sanitize = _ref.sanitize,\n\t      searchWords = _ref.searchWords,\n\t      textToHighlight = _ref.textToHighlight;\n\t  return fillInChunks({\n\t    chunksToHighlight: combineChunks({\n\t      chunks: findChunks({\n\t        autoEscape: autoEscape,\n\t        caseSensitive: caseSensitive,\n\t        sanitize: sanitize,\n\t        searchWords: searchWords,\n\t        textToHighlight: textToHighlight\n\t      })\n\t    }),\n\t    totalLength: textToHighlight ? textToHighlight.length : 0\n\t  });\n\t};\n\t\n\t/**\n\t * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.\n\t * @return {start:number, end:number}[]\n\t */\n\tvar combineChunks = exports.combineChunks = function combineChunks(_ref2) {\n\t  var chunks = _ref2.chunks;\n\t\n\t  chunks = chunks.sort(function (first, second) {\n\t    return first.start - second.start;\n\t  }).reduce(function (processedChunks, nextChunk) {\n\t    // First chunk just goes straight in the array...\n\t    if (processedChunks.length === 0) {\n\t      return [nextChunk];\n\t    } else {\n\t      // ... subsequent chunks get checked to see if they overlap...\n\t      var prevChunk = processedChunks.pop();\n\t      if (nextChunk.start <= prevChunk.end) {\n\t        // It may be the case that prevChunk completely surrounds nextChunk, so take the\n\t        // largest of the end indeces.\n\t        var endIndex = Math.max(prevChunk.end, nextChunk.end);\n\t        processedChunks.push({ start: prevChunk.start, end: endIndex });\n\t      } else {\n\t        processedChunks.push(prevChunk, nextChunk);\n\t      }\n\t      return processedChunks;\n\t    }\n\t  }, []);\n\t\n\t  return chunks;\n\t};\n\t\n\t/**\n\t * Examine text for any matches.\n\t * If we find matches, add them to the returned array as a \"chunk\" object ({start:number, end:number}).\n\t * @return {start:number, end:number}[]\n\t */\n\tvar defaultFindChunks = function defaultFindChunks(_ref3) {\n\t  var autoEscape = _ref3.autoEscape,\n\t      caseSensitive = _ref3.caseSensitive,\n\t      _ref3$sanitize = _ref3.sanitize,\n\t      sanitize = _ref3$sanitize === undefined ? identity : _ref3$sanitize,\n\t      searchWords = _ref3.searchWords,\n\t      textToHighlight = _ref3.textToHighlight;\n\t\n\t  textToHighlight = sanitize(textToHighlight);\n\t\n\t  return searchWords.filter(function (searchWord) {\n\t    return searchWord;\n\t  }) // Remove empty words\n\t  .reduce(function (chunks, searchWord) {\n\t    searchWord = sanitize(searchWord);\n\t\n\t    if (autoEscape) {\n\t      searchWord = escapeRegExpFn(searchWord);\n\t    }\n\t\n\t    var regex = new RegExp(searchWord, caseSensitive ? 'g' : 'gi');\n\t\n\t    var match = void 0;\n\t    while (match = regex.exec(textToHighlight)) {\n\t      var start = match.index;\n\t      var end = regex.lastIndex;\n\t      // We do not return zero-length matches\n\t      if (end > start) {\n\t        chunks.push({ start: start, end: end });\n\t      }\n\t\n\t      // Prevent browsers like Firefox from getting stuck in an infinite loop\n\t      // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/\n\t      if (match.index == regex.lastIndex) {\n\t        regex.lastIndex++;\n\t      }\n\t    }\n\t\n\t    return chunks;\n\t  }, []);\n\t};\n\t// Allow the findChunks to be overridden in findAll,\n\t// but for backwards compatibility we export as the old name\n\texports.findChunks = defaultFindChunks;\n\t\n\t/**\n\t * Given a set of chunks to highlight, create an additional set of chunks\n\t * to represent the bits of text between the highlighted text.\n\t * @param chunksToHighlight {start:number, end:number}[]\n\t * @param totalLength number\n\t * @return {start:number, end:number, highlight:boolean}[]\n\t */\n\t\n\tvar fillInChunks = exports.fillInChunks = function fillInChunks(_ref4) {\n\t  var chunksToHighlight = _ref4.chunksToHighlight,\n\t      totalLength = _ref4.totalLength;\n\t\n\t  var allChunks = [];\n\t  var append = function append(start, end, highlight) {\n\t    if (end - start > 0) {\n\t      allChunks.push({\n\t        start: start,\n\t        end: end,\n\t        highlight: highlight\n\t      });\n\t    }\n\t  };\n\t\n\t  if (chunksToHighlight.length === 0) {\n\t    append(0, totalLength, false);\n\t  } else {\n\t    var lastIndex = 0;\n\t    chunksToHighlight.forEach(function (chunk) {\n\t      append(lastIndex, chunk.start, false);\n\t      append(chunk.start, chunk.end, true);\n\t      lastIndex = chunk.end;\n\t    });\n\t    append(lastIndex, totalLength, false);\n\t  }\n\t  return allChunks;\n\t};\n\t\n\tfunction identity(value) {\n\t  return value;\n\t}\n\t\n\tfunction escapeRegExpFn(str) {\n\t  return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n\t}\n\n/***/ })\n/******/ ]);\n"},"sourceMaps":{"js":{"version":3,"sources":["webpack:///webpack/bootstrap 54ecab42ff588aaa1223","webpack:///./src/index.js","webpack:///./src/utils.js"],"names":["combineChunks","fillInChunks","findAll","findChunks","autoEscape","caseSensitive","defaultFindChunks","sanitize","searchWords","textToHighlight","chunksToHighlight","chunks","totalLength","length","sort","first","second","start","reduce","processedChunks","nextChunk","prevChunk","pop","end","endIndex","Math","max","push","identity","filter","searchWord","escapeRegExpFn","regex","RegExp","match","exec","index","lastIndex","allChunks","append","highlight","forEach","chunk","value","str","replace"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 54ecab42ff588aaa1223","/** @flow */\nexport { combineChunks, fillInChunks, findAll, findChunks } from './utils'\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/**\n * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.\n * @return Array of \"chunks\" (where a Chunk is { start:number, end:number, highlight:boolean })\n */\nexport const findAll = ({\n  autoEscape,\n  caseSensitive = false,\n  findChunks = defaultFindChunks,\n  sanitize,\n  searchWords,\n  textToHighlight\n}) => (\n  fillInChunks({\n    chunksToHighlight: combineChunks({\n      chunks: findChunks({\n        autoEscape,\n        caseSensitive,\n        sanitize,\n        searchWords,\n        textToHighlight\n      })\n    }),\n    totalLength: textToHighlight ? textToHighlight.length : 0\n  })\n)\n\n/**\n * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.\n * @return {start:number, end:number}[]\n */\nexport const combineChunks = ({\n  chunks\n}) => {\n  chunks = chunks\n    .sort((first, second) => first.start - second.start)\n    .reduce((processedChunks, nextChunk) => {\n      // First chunk just goes straight in the array...\n      if (processedChunks.length === 0) {\n        return [nextChunk]\n      } else {\n        // ... subsequent chunks get checked to see if they overlap...\n        const prevChunk = processedChunks.pop()\n        if (nextChunk.start <= prevChunk.end) {\n          // It may be the case that prevChunk completely surrounds nextChunk, so take the\n          // largest of the end indeces.\n          const endIndex = Math.max(prevChunk.end, nextChunk.end)\n          processedChunks.push({start: prevChunk.start, end: endIndex})\n        } else {\n          processedChunks.push(prevChunk, nextChunk)\n        }\n        return processedChunks\n      }\n    }, [])\n\n  return chunks\n}\n\n/**\n * Examine text for any matches.\n * If we find matches, add them to the returned array as a \"chunk\" object ({start:number, end:number}).\n * @return {start:number, end:number}[]\n */\nconst defaultFindChunks = ({\n  autoEscape,\n  caseSensitive,\n  sanitize = identity,\n  searchWords,\n  textToHighlight\n}) => {\n  textToHighlight = sanitize(textToHighlight)\n\n  return searchWords\n    .filter(searchWord => searchWord) // Remove empty words\n    .reduce((chunks, searchWord) => {\n      searchWord = sanitize(searchWord)\n\n      if (autoEscape) {\n        searchWord = escapeRegExpFn(searchWord)\n      }\n\n      const regex = new RegExp(searchWord, caseSensitive ? 'g' : 'gi')\n\n      let match\n      while ((match = regex.exec(textToHighlight))) {\n        let start = match.index\n        let end = regex.lastIndex\n        // We do not return zero-length matches\n        if (end > start) {\n          chunks.push({start, end})\n        }\n\n        // Prevent browsers like Firefox from getting stuck in an infinite loop\n        // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/\n        if (match.index == regex.lastIndex) {\n          regex.lastIndex++\n        }\n      }\n\n      return chunks\n    }, [])\n}\n// Allow the findChunks to be overridden in findAll,\n// but for backwards compatibility we export as the old name\nexport {defaultFindChunks as findChunks}\n\n/**\n * Given a set of chunks to highlight, create an additional set of chunks\n * to represent the bits of text between the highlighted text.\n * @param chunksToHighlight {start:number, end:number}[]\n * @param totalLength number\n * @return {start:number, end:number, highlight:boolean}[]\n */\nexport const fillInChunks = ({\n  chunksToHighlight,\n  totalLength\n}) => {\n  const allChunks = []\n  const append = (start, end, highlight) => {\n    if (end - start > 0) {\n      allChunks.push({\n        start,\n        end,\n        highlight\n      })\n    }\n  }\n\n  if (chunksToHighlight.length === 0) {\n    append(0, totalLength, false)\n  } else {\n    let lastIndex = 0\n    chunksToHighlight.forEach((chunk) => {\n      append(lastIndex, chunk.start, false)\n      append(chunk.start, chunk.end, true)\n      lastIndex = chunk.end\n    })\n    append(lastIndex, totalLength, false)\n  }\n  return allChunks\n}\n\nfunction identity (value) {\n  return value\n}\n\nfunction escapeRegExpFn (str) {\n  return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js"],"sourceRoot":""}},"error":null,"hash":"4d6fe48b6a90705f411888b77081965a","cacheData":{"env":{}}}